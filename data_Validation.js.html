<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Lodash Fantasy</title>
    
    <meta name="description" content="Fantasy Land compatible types built with lodash." />
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":false,"cleverLinks":false,"applicationName":"lodash-fantasy","collapseSymbols":false,"default":{"outputSourceFiles":true},"linenums":true,"meta":{"description":"Fantasy Land compatible types built with lodash.","title":"Lodash Fantasy"},"openGraph":{"type":"website"}};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">lodash-fantasy</a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">
    
        <li class="item" data-name="Failure">
            <span class="title">
                <a href="Failure.html">Failure</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Failure.from"><a href="Failure.html#.from">from</a></li>
            
                <li data-name="Failure#ap"><a href="Failure.html#ap">ap</a></li>
            
                <li data-name="Failure#bimap"><a href="Failure.html#bimap">bimap</a></li>
            
                <li data-name="Failure#chain"><a href="Failure.html#chain">chain</a></li>
            
                <li data-name="Failure#concat"><a href="Failure.html#concat">concat</a></li>
            
                <li data-name="Failure#equals"><a href="Failure.html#equals">equals</a></li>
            
                <li data-name="Failure#ifSuccess"><a href="Failure.html#ifSuccess">ifSuccess</a></li>
            
                <li data-name="Failure#isFailure"><a href="Failure.html#isFailure">isFailure</a></li>
            
                <li data-name="Failure#isSuccess"><a href="Failure.html#isSuccess">isSuccess</a></li>
            
                <li data-name="Failure#map"><a href="Failure.html#map">map</a></li>
            
                <li data-name="Failure#of"><a href="Failure.html#of">of</a></li>
            
                <li data-name="Failure#orElse"><a href="Failure.html#orElse">orElse</a></li>
            
                <li data-name="Failure#orElseThrow"><a href="Failure.html#orElseThrow">orElseThrow</a></li>
            
                <li data-name="Failure#toPromise"><a href="Failure.html#toPromise">toPromise</a></li>
            
                <li data-name="Failure#toPromiseWith"><a href="Failure.html#toPromiseWith">toPromiseWith</a></li>
            
                <li data-name="Failure#toString"><a href="Failure.html#toString">toString</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Success">
            <span class="title">
                <a href="Success.html">Success</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Success.from"><a href="Success.html#.from">from</a></li>
            
                <li data-name="Success#ap"><a href="Success.html#ap">ap</a></li>
            
                <li data-name="Success#bimap"><a href="Success.html#bimap">bimap</a></li>
            
                <li data-name="Success#chain"><a href="Success.html#chain">chain</a></li>
            
                <li data-name="Success#concat"><a href="Success.html#concat">concat</a></li>
            
                <li data-name="Success#equals"><a href="Success.html#equals">equals</a></li>
            
                <li data-name="Success#ifSuccess"><a href="Success.html#ifSuccess">ifSuccess</a></li>
            
                <li data-name="Success#isFailure"><a href="Success.html#isFailure">isFailure</a></li>
            
                <li data-name="Success#isSuccess"><a href="Success.html#isSuccess">isSuccess</a></li>
            
                <li data-name="Success#map"><a href="Success.html#map">map</a></li>
            
                <li data-name="Success#of"><a href="Success.html#of">of</a></li>
            
                <li data-name="Success#orElse"><a href="Success.html#orElse">orElse</a></li>
            
                <li data-name="Success#orElseThrow"><a href="Success.html#orElseThrow">orElseThrow</a></li>
            
                <li data-name="Success#toPromise"><a href="Success.html#toPromise">toPromise</a></li>
            
                <li data-name="Success#toPromiseWith"><a href="Success.html#toPromiseWith">toPromiseWith</a></li>
            
                <li data-name="Success#toString"><a href="Success.html#toString">toString</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Validation">
            <span class="title">
                <a href="Validation.html">Validation</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Validation.all"><a href="Validation.html#.all">all</a></li>
            
                <li data-name="Validation.any"><a href="Validation.html#.any">any</a></li>
            
                <li data-name="Validation.concat"><a href="Validation.html#.concat">concat</a></li>
            
                <li data-name="Validation.each"><a href="Validation.html#.each">each</a></li>
            
                <li data-name="Validation.empty"><a href="Validation.html#.empty">empty</a></li>
            
                <li data-name="Validation.equals"><a href="Validation.html#.equals">equals</a></li>
            
                <li data-name="Validation.Failure"><a href="Validation.html#.Failure">Failure</a></li>
            
                <li data-name="Validation.filter"><a href="Validation.html#.filter">filter</a></li>
            
                <li data-name="Validation.from"><a href="Validation.html#.from">from</a></li>
            
                <li data-name="Validation.isFailure"><a href="Validation.html#.isFailure">isFailure</a></li>
            
                <li data-name="Validation.isSuccess"><a href="Validation.html#.isSuccess">isSuccess</a></li>
            
                <li data-name="Validation.isValidation"><a href="Validation.html#.isValidation">isValidation</a></li>
            
                <li data-name="Validation.map"><a href="Validation.html#.map">map</a></li>
            
                <li data-name="Validation.mapIn"><a href="Validation.html#.mapIn">mapIn</a></li>
            
                <li data-name="Validation.of"><a href="Validation.html#.of">of</a></li>
            
                <li data-name="Validation.reduce"><a href="Validation.html#.reduce">reduce</a></li>
            
                <li data-name="Validation.Success"><a href="Validation.html#.Success">Success</a></li>
            
                <li data-name="Validation.toPromise"><a href="Validation.html#.toPromise">toPromise</a></li>
            
                <li data-name="Validation.toPromiseWith"><a href="Validation.html#.toPromiseWith">toPromiseWith</a></li>
            
                <li data-name="Validation.try"><a href="Validation.html#.try">try</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Validation#ap"><a href="Validation.html#ap">ap</a></li>
            
                <li data-name="Validation#bimap"><a href="Validation.html#bimap">bimap</a></li>
            
                <li data-name="Validation#chain"><a href="Validation.html#chain">chain</a></li>
            
                <li data-name="Validation#concat"><a href="Validation.html#concat">concat</a></li>
            
                <li data-name="Validation#equals"><a href="Validation.html#equals">equals</a></li>
            
                <li data-name="Validation#ifSuccess"><a href="Validation.html#ifSuccess">ifSuccess</a></li>
            
                <li data-name="Validation#isFailure"><a href="Validation.html#isFailure">isFailure</a></li>
            
                <li data-name="Validation#isSuccess"><a href="Validation.html#isSuccess">isSuccess</a></li>
            
                <li data-name="Validation#map"><a href="Validation.html#map">map</a></li>
            
                <li data-name="Validation#of"><a href="Validation.html#of">of</a></li>
            
                <li data-name="Validation#orElse"><a href="Validation.html#orElse">orElse</a></li>
            
                <li data-name="Validation#orElseThrow"><a href="Validation.html#orElseThrow">orElseThrow</a></li>
            
                <li data-name="Validation#toPromise"><a href="Validation.html#toPromise">toPromise</a></li>
            
                <li data-name="Validation#toPromiseWith"><a href="Validation.html#toPromiseWith">toPromiseWith</a></li>
            
                <li data-name="Validation#toString"><a href="Validation.html#toString">toString</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
    </ul>
</div>
    <div class="main">
        <h1 class="page-title" data-filename="data_Validation.js.html">Source: data/Validation.js</h1>
        


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

// Third Party
const concat = require("lodash/fp/concat");
const curry = require("lodash/fp/curry");
const curryN = require("lodash/fp/curryN");
const each = require("lodash/fp/each");
const filter = require("lodash/fp/filter");
const find = require("lodash/fp/find");
const flow = require("lodash/fp/flow");
const get = require("lodash/fp/get");
const invoke = require("lodash/fp/invoke");
const isEqual = require("lodash/fp/isEqual");
const isUndefined = require("lodash/fp/isUndefined");
const map = require("lodash/fp/map");
const negate = require("lodash/fp/negate");
const reduce = require("lodash/fp/reduce");
const stream = require("lodash/fp");

/**
 * Invokes &lt;code>method&lt;/code> with &lt;code>value&lt;/code> in &lt;code>source&lt;/code> object.
 * @private
 * @param {String} methodName - Method name to invoke.
 * @param {T} value - Value with which to invoke the method.
 * @param {Object} source - The object on which the method is invoked.
 * @return {U} Arbitrary value.
 */
const invokeIn = curryN(3, (methodName, value, source) => source[methodName](value));

/**
 * Invokes &lt;code>method&lt;/code> in &lt;code>source&lt;/code> object with &lt;code>value&lt;/code>.
 * @private
 * @param {String} methodName - Method name to invoke.
 * @param {Object} source - The object on which the method is invoked.
 * @param {T} value - Value with which to invoke the method.
 * @return {U} Arbitrary value.
 */
const invokeWith = curryN(3, (methodName, source, value) => source[methodName](value));

/**
 * The &lt;code>Validation&lt;/code> type is intended for validating values and aggregating failures. It is a disjunction
 * similar to &lt;code>Either&lt;/code>. The key difference of the &lt;code>Validation&lt;/code> type is the focus on failure
 * aggregation as opposed to failing once and ignoring all other failures. Much like &lt;code>Either&lt;/code>,
 * &lt;code>Validation&lt;/code> is right-biased.
 *
 * @class
 * @example &lt;caption>Value validation function&lt;/caption>
 *
 * const isEmpty = require("lodash/fp/isEmpty");
 * const isString = require("lodash/fp/isString");
 * const Validation = require("lodash-fantasy/data/Validation");
 *
 * function validateStringPresence(value) {
 *   return isString(value) &amp;&amp; !isEmpty(value) ?
 *     Validation.Success.from(value) :
 *     Validation.Failure.from("value should be a non-empty string");
 * }
 *
 * module.exports = validateStringPresence;
 *
 * @example &lt;caption>Abstract validation rule&lt;/caption>
 *
 * const Validation = require("lodash-fantasy/data/Validation");
 *
 * module.exports = (condition, value, message) => condition(value) ?
 *   Validation.Success.from(value) :
 *   Validation.Failure.from(message(value)); // Pass value into the message for possible reference
 */
class Validation {
  /**
   * @static
   * @property {Failure} Failure - Validation failure.
   */
  static get Failure() {
    return Failure;
  }

  /**
   * @static
   * @property {Success} Success - Validation success.
   */
  static get Success() {
    return Success;
  }

  /**
   * Returns a &lt;code>Validation&lt;/code> that resolves all of the validations in the collection into a single validation.
   * Unlike &lt;code>Promise&lt;/code>, &lt;code>Validation.all&lt;/code> aggregates all of the failures into a single instance of
   * &lt;code>Validation&lt;/code>. However, like &lt;code>Promise&lt;/code>, &lt;code>Validation.all&lt;/code> collects all of the values
   * for &lt;code>Success&lt;/code>es when &lt;em>all&lt;/em> items in the collection are a &lt;code>Success&lt;/code>.
   * @static
   * @member
   * @param {Validation[]} validations - Collection of validations.
   * @return {Validation} A &lt;code>Validation&lt;/code> representing all &lt;code>Success&lt;/code> or &lt;code>Failure&lt;/code>
   * values.
   * @example
   *
   * const v1 = validationPropertyAIn(context1);
   * // => Success(context1)
   *
   * const v2 = validationPropertyBIn(context2);
   * // => Success(context2)
   *
   * const v3 = validationPropertyCIn(context3);
   * // => Failure("A failure.")
   *
   * const v4 = validationPropertyDIn(context4);
   * // => Failure("B failure.")
   *
   * Validation.all([v1, v2]);
   * // => Success([context1, context2])
   *
   * Validation.all([v1, v2, v3]);
   * // => Failure(["A failure"])
   *
   * Validation.all([v1, v2, v3, v4]);
   * // => Failure(["A failure", "B failure"])
   */
  static all(validations) {
    return find(Validation.isFailure, validations) ?
      reduce(Validation.concat, Success.empty(), validations) :
      Success.of(stream(validations).map(get("value")).reduce(concat, []));
  }

  /**
   * Returns the first &lt;code>Success&lt;/code> in the collection or a single &lt;code>Failure&lt;/code> for all failures.
   * @static
   * @member
   * @param {Validation[]} validations - Collection of validations.
   * @return {Validation} First &lt;code>Success&lt;/code> or reduced &lt;code>Failure&lt;/code>s.
   * @example
   *
   * const v1 = validationPropertyAIn(context1);
   * // => Success(context1)
   *
   * const v2 = validationPropertyBIn(context2);
   * // => Success(context2)
   *
   * const v3 = validationPropertyCIn(context3);
   * // => Failure("A failure.")
   *
   * const v4 = validationPropertyDIn(context4);
   * // => Failure("B failure.")
   *
   * Validation.any([v1, v2]);
   * // => Success(context1)
   *
   * Validation.any([v1, v2, v3]);
   * // => Failure(["A failure"])
   *
   * Validation.any([v1, v2, v3, v4]);
   * // => Failure(["A failure", "B failure"])
   */
  static any(validations) {
    return find(Validation.isSuccess, validations) ||
      reduce(Validation.concat, Success.empty(), validations);
  }

  /**
   * Creates an empty &lt;code>Success&lt;/code>.
   * @static
   * @member
   * @return {Success} Empty &lt;code>Success&lt;/code> instance.
   * @example
   *
   * const v1 = Validation.empty();
   * // => Success()
   */
  static empty() {
    return new Success();
  }

  /**
   * Determines whether or not the value is a &lt;code>Failure&lt;/code>.
   * @static
   * @member
   * @param {*} value - Value to check.
   * @return {Boolean} &lt;code>true&lt;/code> for &lt;code>Failure&lt;/code>; &lt;code>false&lt;/code> for &lt;code>Success&lt;/code>.
   * @example
   *
   * isFailure();
   * // => false
   *
   * isFailure(null);
   * // => false
   *
   * isFailure(Success.from(0));
   * // => false
   *
   * isFailure(Failure.from("Error"));
   * // => true
   */
  static isFailure(value) {
    return value instanceof Failure;
  }

  /**
   * Determines whether or not the value is a &lt;code>Success&lt;/code>.
   * @static
   * @member
   * @param {*} value - Value to check.
   * @return {Boolean} &lt;code>true&lt;/code> for &lt;code>Success&lt;/code>; &lt;code>false&lt;/code> for &lt;code>Failure&lt;/code>.
   * @example
   *
   * isSuccess();
   * // => false
   *
   * isSuccess(null);
   * // => false
   *
   * isSuccess(Success.from(0));
   * // => true
   *
   * isSuccess(Failure.from("Error"));
   * // => false
   */
  static isSuccess(value) {
    return value instanceof Success;
  }

  /**
   * Determines whether or not the value is a &lt;code>Validation&lt;/code>.
   * @static
   * @member
   * @param {*} value - Value to check.
   * @return {Boolean} &lt;code>true&lt;/code> for &lt;code>Validation&lt;/code>; &lt;code>false&lt;/code> for anything else.
   * @example
   *
   * isValidation();
   * // => false
   *
   * isValidation(null);
   * // => false
   *
   * isValidation(Success.from(0));
   * // => true
   *
   * isValidation(Failure.from("Error"));
   * // => true
   */
  static isValidation(value) {
    return value instanceof Validation;
  }

  /**
   * Creates a new &lt;code>Validation&lt;/code> from a &lt;code>value&lt;/code>. If the &lt;code>value&lt;/code> is already a
   * &lt;code>Validation&lt;/code> instance, the &lt;code>value&lt;/code> is returned unchanged. Otherwise, a new
   * &lt;code>Success&lt;/code> is made with the &lt;code>value&lt;/code>.
   * @static
   * @member
   * @param {*} value - Value to wrap in a &lt;code>Validation&lt;/code>.
   * @return {Validation} &lt;code>Validation&lt;/code> when is the &lt;code>value&lt;/code> already wrapped or
   * &lt;code>Success&lt;/code> wrapped &lt;code>value&lt;/code>.
   *
   * Validation.from();
   * // => Success()
   *
   * Validation.from(true);
   * // => Success(true)
   *
   * Validation.from(Success.from(value));
   * // => Success(value)
   *
   * Validation.from(Failure.from("Error message"));
   * // => Failure(["Error message"])
   */
  static from(value) {
    return this.isValidation(value) ? value : this.of(value);
  }

  /**
   * Wraps the &lt;code>value&lt;/code> in a &lt;code>Success&lt;/code>. No parts of &lt;code>value&lt;/code> are checked.
   * @static
   * @member
   * @param {*} value - Value to wrap.
   * @return {Success} &lt;code>Success&lt;/code> wrapped &lt;code>value&lt;/code>.
   * @example
   *
   * Validation.of();
   * // => Success()
   *
   * Validation.of(true);
   * // => Success(true)
   *
   * Validation.of(Success.from(value));
   * // => Success(Success(value))
   *
   * Validation.from(Failure.from("Error message"));
   * // => Success(Failure(["Error message"]))
   */
  static of(value) {
    return new Success(value);
  }

  /**
   * Tries to invoke a &lt;code>supplier&lt;/code>. The result of the &lt;code>supplier&lt;/code> is returned in a
   * &lt;code>Success&lt;/code>. If an exception is thrown, the error is returned in a &lt;code>Failure&lt;/code>. The
   * &lt;code>function&lt;/code> takes no arguments.
   * @static
   * @member
   * @param {Supplier} supplier - Function to invoke.
   * @return {Validation} &lt;code>Success&lt;/code> wrapped &lt;code>method&lt;/code> or &lt;code>Failure&lt;/code> wrapped
   * &lt;code>error&lt;/code>.
   * @example
   *
   * Validation.try(normalFunction);
   * // => Success(returnValue)
   *
   * Validation.try(throwableFunction);
   * // => Failure([error])
   */
  static try(method) {
    try {
      return Success.from(method());
    } catch (error) {
      return Failure.from(error);
    }
  }

  /**
   * Creates a &lt;code>Validation&lt;/code> instance. Use &lt;code>Failure&lt;/code> or &lt;code>Success&lt;/code>.
   * @param {*} value - Value to wrap.
   * @return {Validation} &lt;code>Validation&lt;/code> wrapped &lt;code>value&lt;/code>.
   * @example &lt;caption>Via &lt;code>new&lt;/code>&lt;/caption
   *
   * const v1 = new Success(value);
   * const v2 = new Failure(message);
   *
   * @example &lt;caption>Via functions&lt;/caption>
   *
   * const v3 = Success.from(value);
   * const v4 = Failure.from(message);
   */
  constructor(value) {
    this.value = value;
  }

  /**
   * Applies the function contained in the instance of a &lt;code>Success&lt;/code> to the value contained in the provided
   * &lt;code>Success&lt;/code>, producing a &lt;code>Success&lt;/code> containing the result. If the instance is
   * &lt;code>Failure&lt;/code>, the result will be the the &lt;code>Failure&lt;/code> instance. If the instance is
   * &lt;code>Success&lt;/code> and the provided validation is &lt;code>Failure&lt;/code>, the result is the provided
   * &lt;code>Failure&lt;/code>.
   * @abstract
   * @function ap
   * @memberof Validation
   * @instance
   * @param {Validation} other - Value to apply to the function wrapped in the &lt;code>Success&lt;/code>.
   * @return {Validation} &lt;code>Success&lt;/code> wrapped applied function or &lt;code>Failure&lt;/code>.
   * @example &lt;caption>Success#ap&lt;/caption>
   *
   * const createPerson = curryN(4, Person.create); // Person.create(name, birthdate, address, email)
   *
   * Success.from(createPerson) // => Success(createPerson)
   *   .ap(validate(name)) // => Success(name)
   *   .ap(validate(birthdate)) // => Success(birthdate)
   *   .ap(validate(address)) // => Success(address)
   *   .ap(validate(email)) // => Success(email)
   *   .ifSuccess(console.log) // => Log Person.create() response
   *   .orElse(each(console.error)) // => Logs first error since #ap short circuits after the first Failure
   */

  /**
   * Transforms a &lt;code>Validation&lt;/code> by applying the first function to the contained value for a
   * &lt;code>Failure&lt;/code> or the second function for a &lt;code>Success&lt;/code>. The result of each map is wrapped in the
   * corresponding type.
   * @abstract
   * @function bimap
   * @memberof Validation
   * @instance
   * @param {Function} failureMap - Map to apply to the &lt;code>Failure&lt;/code>.
   * @param {Function} successMap - Map to apply to the &lt;code>Success&lt;/code>.
   * @return {Validation} &lt;code>Validation&lt;/code> wrapped value mapped with the corresponding mapping function.
   * @example
   *
   * validateRequest(request)
   *   .bimap(toBadRequestResponse, PersonModel.create)
   *   // ... other actions in workflow
   */

  /**
   * Applies the provided function to the value contained for a &lt;code>Success&lt;/code>. The function should return the
   * value wrapped in a &lt;code>Validation&lt;/code>. If the instance is a &lt;code>Failure&lt;/code>, the function is ignored and
   * then instance is returned unchanged.
   * @abstract
   * @function chain
   * @memberof Validation
   * @instance
   * @param {Chain.&lt;Validation>} method - The function to invoke with the value.
   * @return {Validation} &lt;code>Validation&lt;/code> wrapped value returned by the provided &lt;code>method&lt;/code>.
   * @example &lt;caption>Success#chain&lt;/caption>
   *
   * const person = { ... };
   * const validateResponse = response => HttpStatus.isSuccess(response.statusCode) ?
   *   Success(response) :
   *   Failure(response.statusMessage);
   *
   * const updatePerson = flow(Person.update, validateResponse); // Expects instance of Person
   *
   * const validations = [
   *   validatePersonName(person), // => Success(person)
   *   validatePersonBirthdate(person), // => Success(person)
   *   validatePersonAddress(person), // => Failure([error1])
   *   validatePersonEmail(person) // => Failure([error2])
   * ];
   *
   * Validation.reduce(Validation.concat, Success.empty(), validations) // => Validation&lt;Person>
   *   .chain(updatePerson) // => Validation&lt;Response>
   *   .ifSuccess(doSomethingWithResponse)
   *   .orElse(each(console.error)); // Log all errors
   */

  /**
   * Concatenates another &lt;code>Validation&lt;/code> instance with the current instance.
   * @abstract
   * @function concat
   * @memberof Validation
   * @instance
   * @param {Validation} other - Other &lt;code>Validation&lt;/code> to concatenation.
   * @return {Validation} Concatenated validations.
   * @example &lt;caption>Empty Success with Empty Success&lt;/caption>
   *
   * Success.empty().concat(Success.empty());
   * // => Success.empty()
   *
   * @example &lt;caption>Empty Success with Success&lt;/caption>
   *
   * Success.empty().concat(Success.from(value));
   * // => Success(value)
   *
   * @example &lt;caption>Success with Empty Success&lt;/caption>
   *
   * Success.from(value).concat(Success.empty());
   * // => Success(value)
   *
   * @example &lt;caption>Success1 with Success2&lt;/caption>
   *
   * Success.from(value1).concat(Success.from(value2));
   * // => Success(value1)
   *
   * @example &lt;caption>Any Success with Failure&lt;/caption>
   *
   * anySuccess.concat(Failure.from(error));
   * // => Failure([error])
   *
   * @example &lt;caption>Empty Failure with Any Success&lt;/caption>
   *
   * Failure.from().concat(anySuccess);
   * // => Failure([])
   *
   * @example &lt;caption>Failure with Any Success&lt;/caption>
   *
   * Failure.from(error).concat(Success);
   * // => Failure([error])
   *
   * @example &lt;caption>Empty Failure with Empty Failure&lt;/caption>
   *
   * Failure.from().concat(Failure.from());
   * // => Failure([])
   *
   * @example &lt;caption>Empty Failure with Failure&lt;/caption>
   *
   * Failure.from().concat(Failure.from(error));
   * // => Failure([error])
   *
   * @example &lt;caption>Failure with Failure&lt;/caption>
   *
   * Failure.from(error1).concat(Failure.from(error2));
   * // => Failure([error1, error2])
   */

  /**
   * Determines whether or not the &lt;code>other&lt;/code> is equal in value to the current (&lt;code>this&lt;/code>). This is
   * &lt;strong>not&lt;/strong> a reference check.
   * @param {*} other - Other value to check.
   * @return {Boolean} &lt;code>true&lt;/code> if the two validations are equal; &lt;code>false&lt;/code> if not equal.
   * @example &lt;caption>Reflexivity&lt;/caption>
   *
   * v1.equals(v1) === true;
   * // => true
   *
   * @example &lt;caption>Symmetry&lt;/caption>
   *
   * v1.equals(v2) === v2.equals(v1);
   * // => true
   *
   * @example &lt;caption>Transitivity&lt;/caption>
   *
   * (v1.equals(v2) === v2.equals(v3)) &amp;&amp; v1.equals(v3)
   * // => true
   */
  equals(other) {
    return isEqual(this, other);
  }

  /**
   * Applies the provided function to the value contain for a &lt;code>Success&lt;/code>. Any return value from the function
   * is ignored. If the instance is a &lt;code>Failure&lt;/code>, the function is ignored and the instance is returned.
   * @abstract
   * @function ifSuccess
   * @memberof Validation
   * @instance
   * @param {Consumer} method -The function to invoke with the value;
   * @return {Validation} Current instance.
   * @example &lt;caption>Success#ifSuccess&lt;/caption>
   *
   * Success.from(value).ifSuccess(doSomething); // doSomething(value)
   * // => Success(value)
   *
   * @example &lt;caption>Failure#ifSuccess&lt;/caption>
   *
   * Failure.from(error).ifSuccess(doSomething); // void
   * // => Failure([error])
   */

  /**
   * Determines whether or not the instance is a &lt;code>Failure&lt;/code> or not.
   * @return {Boolean} &lt;code>true&lt;/code> if the instance is a &lt;code>Failure&lt;/code>; &lt;code>false&lt;/code> is not.
   * @example &lt;caption>Success#isFailure&lt;/caption>
   *
   * Success.from(value).isFailure();
   * // => false
   *
   * @example &lt;caption>Failure#isFailure&lt;/caption>
   *
   * Failure.from(error).isFailure();
   * // => true
   */
  isFailure() {
    return this instanceof Failure;
  }

  /**
   * Determines whether or not the instance is a &lt;code>Success&lt;/code> or not.
   * @return {Boolean} &lt;code>true&lt;/code> if the instance is a &lt;code>Success&lt;/code>; &lt;code>false&lt;/code> is not.
   * @example &lt;caption>Success&lt;/caption>
   *
   * Success.from(value).isFailure();
   * // => true
   *
   * @example &lt;caption>Failure#isSuccess&lt;/caption>
   *
   * Failure.from(error).isFailure();
   * // => false
   */
  isSuccess() {
    return this instanceof Success;
  }

  /**
   * Applies the provided function to the value contained for a &lt;code>Success&lt;/code> which is, in turn, wrapped in a
   * &lt;code>Success&lt;/code>. If the instance is a &lt;code>Failure&lt;/code>, the function is ignored and then instance is
   * returned unchanged.
   * @abstract
   * @function map
   * @memberof Validation
   * @instance
   * @param {Function} method - The function to invoke with the value.
   * @return {Validation} &lt;code>Validation&lt;/code> wrapped value mapped with the provided &lt;code>method&lt;/code>.
   * @example
   *
   * Success.from([1, 3, 2]).map(flow(sort, join(", ")));
   * // => Success("1, 2, 3")
   *
   * Failure.from(error).map(flow(sort, join(", ")));
   * // => Failure([error])
   */

  /**
   * @see Validation.of
   */
  of(value) {
    return Validation.of(value);
  }

  /**
   * Applies the provided function to the value contain for a &lt;code>Failure&lt;/code>. Any return value from the function
   * is ignored. If the instance is a &lt;code>Success&lt;/code>, the function is ignored and the instance is returned.
   * @abstract
   * @function orElse
   * @memberof Validation
   * @instance
   * @param {Consumer} method -The function to invoke with the value;
   * @return {Validation} Current instance.
   * @example &lt;caption>Success#orElse&lt;/caption>
   *
   * Success.from(value).orElse(doSomething); // void
   * // => Success(value)
   *
   * @example &lt;caption>Failure#orElse&lt;/caption>
   *
   * Failure.from(error).orElse(doSomething); // doSomething([error])
   * // => Failure([error])
   */

  /**
   * Applies the provided function to the value contain for a &lt;code>Failure&lt;/code> and throws the resulting
   * &lt;code>Error&lt;/code>. If the instance is a &lt;code>Success&lt;/code>, the function is ignored and the instance is
   * returned.
   * @abstract
   * @function orElseThrow
   * @memberof Validation
   * @instance
   * @param {Consumer} method -The function to invoke with the value;
   * @throws {Error} returned by the provided function.
   * @example &lt;caption>Success#orElseThrow&lt;/caption>
   *
   * Success.from(value).orElseThrow(createException); // void
   * // => Success(value)
   *
   * @example &lt;caption>Failure#orElseThrow&lt;/caption>
   *
   * Failure.from(error).orElseThrow(createException); // createException([error])
   * // => Failure([error])
   */

  /**
   * Converts the validation to a &lt;code>Promise&lt;/code>. &lt;code>Success&lt;/code>es are &lt;code>resolve&lt;/code>d and
   * &lt;code>Failure&lt;/code>s are &lt;code>reject&lt;/code>ed.
   * @abstract
   * @function toPromise
   * @memberof Validation
   * @instance
   * @return {Promise} &lt;code>Promise&lt;/code> wrapped &lt;code>value&lt;/code>.
   * @example &lt;caption>Success#toPromise&lt;/caption>
   *
   * Success.from(value).toPromise();
   * // => Promise.resolve(value);
   *
   * @example &lt;caption>Failure#toPromise&lt;/caption>
   *
   * Failure.from(error).toPromise();
   * // => Promise.reject([error]);
   */

  /**
   * Converts the validation to a &lt;code>Promise&lt;/code> using the provided &lt;code>Promise&lt;/code> implementation.
   * &lt;code>Success&lt;/code>es are &lt;code>resolve&lt;/code>d and &lt;code>Failure&lt;/code>s are &lt;code>reject&lt;/code>ed.
   * @abstract
   * @function toPromiseWith
   * @memberof Validation
   * @instance
   * @param {Promise} promise - Promise implementation.
   * @return {Promise} &lt;code>Promise&lt;/code> wrapped &lt;code>value&lt;/code>.
   * @example &lt;caption>Success#toPromiseWith&lt;/caption>
   *
   * const Bluebird = require("bluebird");
   *
   * Success.from(value).toPromiseWith(Bluebird);
   * // => Promise.resolve(value);
   *
   * @example &lt;caption>Failure#toPromiseWith&lt;/caption>
   *
   * const Bluebird = require("bluebird");
   *
   * Failure.from(error).toPromiseWith(Bluebird);
   * // => Promise.reject([error]);
   */

  /**
   * Returns a &lt;code>String&lt;/code> representation of the &lt;code>Validation&lt;/code>.
   * @abstract
   * @function toString
   * @memberof Validation
   * @instance
   * @return {String} &lt;code>String&lt;/code> representation.
   * @example &lt;caption>Success#toString&lt;/caption>
   *
   * Success.from(1).toString();
   * // => "Validation.Success(1)"
   *
   * @example &lt;caption>Failure#toString&lt;/caption>
   *
   * Failure.from("Error message").toString();
   * // => "Validation.Failure('Error message')"
   */
}

/**
 * Concatenates two &lt;code>Validation&lt;/code> instances together.
 * @static
 * @member
 * @param {Validation} left - Left concatenation value.
 * @param {Validation} right - Right concatenation value.
 * @return {Validation} Concatenated validations.
 * @example &lt;caption>Concatenating distinct validations&lt;/caption>
 *
 * const validations = [
 *   validatePersonName(person), // => Success(person)
 *   validatePersonBirthdate(person), // => Success(person)
 *   validatePersonAddress(person), // => Failure([error1])
 *   validatePersonEmail(person) // => Failure([error2])
 * ];
 *
 * Validation.reduce(Validation.concat, Success.empty(), validations);
 * // => Failure([error1, error2])
 */
Validation.concat = invokeWith("concat");

/**
 * Iterates over a collection of validations and invokes the &lt;code>iteratee&lt;/code> for each validation. The
 * &lt;code>iteratee&lt;/code> is invoked with one argument: &lt;code>(validation)&lt;/code>. Iteratee functions may exit iteration
 * early by explicitly returning a &lt;code>Failure&lt;/code>.
 * @static
 * @member
 * @param {Consumer} iteratee - The function to invoke per iteration.
 * @param {Validation[]} validations - Collection of validations over which to iterate.
 * @return {Validation[]} Current &lt;code>Validation&lt;/code> collection.
 * @example
 *
 * const validations = [
 *   validatePerson(person1), // => Success(person1)
 *   validatePerson(person2), // => Success(person2)
 *   validatePerson(person3), // => Failure([error1, error2])
 *   validatePerson(person4) // => Failure([error2])
 * ];
 *
 * Validation.each(validation => validation.orElse(flow(join(", "), console.error)), validations);
 * // => Logs 'error1, error2' then 'error2'
 * //
 * // => validations
 */
Validation.each = curry((iteratee, validations) => each(
  flow(iteratee, negate(Validation.isFailure)),
  validations
));

/**
 * Determines whether or not the &lt;code>other&lt;/code> is equal in value to the current (&lt;code>this&lt;/code>). This is
 * &lt;strong>not&lt;/strong> a reference check.
 * @static
 * @member
 * @param {*} other - Other value to check.
 * @return {Boolean} &lt;code>true&lt;/code> if the two validations are equal; &lt;code>false&lt;/code> if not equal.
 * @example &lt;caption>Reflexivity&lt;/caption>
 *
 * Validation.equals(v1, v1) === true;
 * // => true
 *
 * @example &lt;caption>Symmetry&lt;/caption>
 *
 * Validation(v1, v2) === Validation.equals(v2, v1);
 * // => true
 *
 * @example &lt;caption>Transitivity&lt;/caption>
 *
 * (Validation.equals(v1, v2) === Validation.equals(v2, v3)) &amp;&amp; Validation.equals(v1, v3)
 * // => true
 */
Validation.equals = isEqual;

/**
 * Iterates over a collection of validations, returning an array of all validations the &lt;code>predicate&lt;/code> for which
 * returns truthy. The &lt;code>predicate&lt;/code> is invoked with one argument: &lt;code>(validation)&lt;/code>.
 * @static
 * @member
 * @param {Predicate} predicate - The function to invoke per iteration.
 * @param {Validations[]} validations - Collection of validations over which to iterate.
 * @return {Validations[]} Filtered &lt;code>Validation&lt;/code> collection.
 * @example &lt;caption>Filter and log failures&lt;/caption>
 *
 * const validations = [
 *   validatePerson(person1), // => Success(person1)
 *   validatePerson(person2), // => Success(person2)
 *   validatePerson(person3), // => Failure([error1, error2])
 *   validatePerson(person4) // => Failure([error2])
 * ];
 *
 * // Log failures, return successes.
 * Validation.filter(validation => validation.orElse(flow(join(", "), console.error)).isSuccess(), validations);
 * // => Logs 'error1, error2' then 'error2'
 * //
 * // => [Success(person1), Success(person2)]
 */
Validation.filter = filter;

/**
 * Creates an array of values by invoking &lt;code>Validation#map&lt;/code> with the &lt;code>iteratee&lt;/code> for each
 * &lt;code>Validation&lt;/code> in the collection. The iteratee is invoked with one argument: &lt;code>(value)&lt;/code>.
 * @static
 * @member
 * @param {Function} iteratee - The function to invoke per iteration.
 * @param {Validation[]} validations - Collection of validations over which to iterate.
 * @return {Validation[]} Mapped &lt;code>Validation&lt;/code> collection.
 * @example &lt;caption>Mapping each Validation's value&lt;/caption>
 *
 * const validations = [
 *   validatePrice(2.10), // => Success(price1)
 *   validatePrice(2.25), // => Success(price2)
 *   validatePrice("2.50"), // => Failure([error1])
 *   validatePrice("Three dollars") // => Failure([error1])
 * ];
 *
 * Validation.mapIn(Math.floor, validations);
 * // => [Success(2), Success(2), Failure([error1]), Failure([error2])]
 */
Validation.mapIn = curry((iteratee, validations) => map(invokeIn("map", iteratee), validations));

/**
 * Creates an array of values by running each &lt;code>Validation&lt;/code> in collection through the &lt;code>iteratee&lt;/code>.
 * The iteratee is invoked with one argument: &lt;code>(validation)&lt;/code>.
 * @static
 * @member
 * @param {Function} iteratee - The function to invoke per iteration.
 * @param {Validation[]} validations - Collection of validations over which to iterate.
 * @return {Validation[]} Mapped collection.
 * @example &lt;caption>Mapping all validations to promises&lt;/caption>
 *
 * const validations = [
 *   validatePrice(2.10), // => Success(price1)
 *   validatePrice(2.25), // => Success(price2)
 *   validatePrice("2.50"), // => Failure([error1])
 *   validatePrice("Three dollars") // => Failure([error1])
 * ];
 *
 * Validation.map(Validation.toPromise, validations);
 * // => [Promise.resolve(price1), Promise.resolve(price2), Promise.reject([error1]), Promise.reject([error2])]
 */
Validation.map = map;

/**
 * Reduces collection to a value which is the accumulated result of running each validation in the
 * &lt;code>validations&lt;/code> collection through the &lt;code>iteratee&lt;/code>, where each successive invocation is supplied
 * the return value of the previous. The iteratee is invoked with two arguments: &lt;code>(accumulator, value)&lt;/code>.
 * @static
 * @member
 * @param {Reduction} iteratee - The function to invoke per iteration.
 * @param {*} accumulator - The initial value.
 * @param {Validation[]} validations - Collection of validations over which to iterate.
 * @return {*} Accumulator.
 * @example
 *
 * const validations = [
 *   validatePersonName(person), // => Success(person)
 *   validatePersonBirthdate(person), // => Success(person)
 *   validatePersonAddress(person), // => Failure([error1])
 *   validatePersonEmail(person) // => Failure([error2])
 * ];
 *
 * Validation.reduce(Validation.concat, Success.empty(), validations);
 * // => Failure([error1, error2])
 */
Validation.reduce = reduce;

/**
 * Converts a &lt;code>Validation&lt;/code> to a &lt;code>Promise&lt;/code>. Successes are resolved and Failures are rejected.
 * @static
 * @member
 * @param {Validation} value - Validation to convert.
 * @return {Promise} &lt;code>Promise&lt;/code> wrapped &lt;code>value&lt;/code>.
 * @example &lt;caption>Success to Resolved&lt;/caption>
 *
 * Validation.toPromise(Success.from(value));
 * // => Promise.resolve(value);
 *
 * @example &lt;caption>Failure to Rejected&lt;/caption>
 *
 * Validation.toPromise(Failure.from(error));
 * // => Promise.reject([error]);
 */
Validation.toPromise = invoke("toPromise");

/**
 * Converts a validation to a &lt;code>Promise&lt;/code> using the provided &lt;code>Promise&lt;/code> implementation.
 * &lt;code>Success&lt;/code>es are &lt;code>resolve&lt;/code>d and &lt;code>Failure&lt;/code>s are &lt;code>reject&lt;/code>ed.
 * @static
 * @member
 * @param {Promise} promise - Promise implementation.
 * @param {Validation} value - Validation to convert.
 * @return {Promise} &lt;code>Promise&lt;/code> wrapped &lt;code>value&lt;/code>.
 * @example &lt;caption>Convert with bluebird's implementation of Promise&lt;/caption>
 *
 * const toBluebird = Validation.toPromiseWith(require("bluebird"));
 *
 * toBluebird(Success.from(value));
 * // => Promise.resolve(value);
 *
 * toBluebird(Failure.from(error));
 * // => Promise.reject([error]);
 */
Validation.toPromiseWith = invokeIn("toPromise");

/**
 * @class
 * @extends Validation
 * @inheritdoc
 */
class Failure extends Validation {
  /**
   * Creates a new &lt;code>Failure&lt;/code> from a &lt;code>value&lt;/code>. If the &lt;code>value&lt;/code> is already a
   * &lt;code>Validation&lt;/code> instance, the &lt;code>value&lt;/code> is returned unchanged. Otherwise, a new
   * &lt;code>Failure&lt;/code> is made with the &lt;code>value&lt;/code>.
   * @static
   * @param {*} value - Value to wrap in a &lt;code>Failure&lt;/code>.
   * @return {Validation} &lt;code>Validation&lt;/code> when is the &lt;code>value&lt;/code> already wrapped or
   * &lt;code>Failure&lt;/code> wrapped &lt;code>value&lt;/code>.
   * @example &lt;caption>Failure from empty array&lt;/caption>
   *
   * Failure.from();
   * // => Failure([])
   *
   * @example &lt;caption>Failure from arbitrary value&lt;/caption>
   *
   * Failure.from(true);
   * // => Failure([true])
   *
   * @example &lt;caption>Failure from Success&lt;/caption>
   *
   * Failure.from(Success.from(value));
   * // => Success.from(value)
   *
   * @example &lt;caption>Failure from another Failure&lt;/caption>
   *
   * Failure.from(Failure.from("Error message"));
   * // => Failure(["Error message"])
   */
  static from(value) {
    return Validation.isValidation(value) ?
      value :
      new Failure(value);
  }

  constructor(value) {
    super(isUndefined(value) ? [] : [].concat(value));
  }

  ap() {
    return this;
  }

  bimap(failureMap) {
    return Failure.from(failureMap(this.value));
  }

  chain() {
    return this;
  }

  concat(other) {
    return other.isSuccess() ?
      this :
      new Failure(this.value.concat(other.value));
  }

  ifSuccess() {
    return this;
  }

  map() {
    return this;
  }

  orElse(method) {
    method(this.value);

    return this;
  }

  orElseThrow(method) {
    throw method(this.value);
  }

  toPromise() {
    return Promise.reject(this.value);
  }

  toPromiseWith(promise) {
    return promise.reject(this.value);
  }

  toString() {
    return `Validation.Failure(${this.value.join("; ")})`;
  }
}

/**
 * @class
 * @extends Validation
 * @inheritdoc
 */
class Success extends Validation {
  /**
   * Creates a new &lt;code>Success&lt;/code> from a &lt;code>value&lt;/code>. If the &lt;code>value&lt;/code> is already a
   * &lt;code>Validation&lt;/code> instance, the &lt;code>value&lt;/code> is returned unchanged. Otherwise, a new
   * &lt;code>Success&lt;/code> is made with the &lt;code>value&lt;/code>.
   * @static
   * @param {*} value - Value to wrap in a &lt;code>Success&lt;/code>.
   * @return {Validation} &lt;code>Validation&lt;/code> when is the &lt;code>value&lt;/code> already wrapped or
   * &lt;code>Success&lt;/code> wrapped &lt;code>value&lt;/code>.
   * @example &lt;caption>Success from nothing&lt;/caption>
   *
   * Success.from();
   * // => Success()
   *
   * @example &lt;caption>Success from arbitrary value&lt;/caption>
   *
   * Success.from(true);
   * // => Success(true)
   *
   * @example &lt;caption>Success from another Success&lt;/caption>
   *
   * Success.from(Success.from(value));
   * // => Success(value)
   *
   * @example &lt;caption>Success from Failure&lt;/caption>
   *
   * Success.from(Failure.from("Error message"));
   * // => Failure(["Error message"])
   */
  static from(value) {
    return Validation.isValidation(value) ?
      value :
      new Success(value);
  }

  constructor(value) {
    super(value);
  }

  ap(other) {
    return other.map(this.value);
  }

  bimap(leftMap, rightMap) {
    return Success.from(rightMap(this.value));
  }

  chain(method) {
    return Validation.from(method(this.value));
  }

  concat(other) {
    return (other.isSuccess() &amp;&amp; !isUndefined(this.value)) ? this : other;
  }

  ifSuccess(method) {
    method(this.value);

    return this;
  }

  map(method) {
    return Success.of(method(this.value));
  }

  orElse() {
    return this;
  }

  orElseThrow() {
    void 0;
  }

  toPromise() {
    return Promise.resolve(this.value);
  }

  toPromiseWith(promise) {
    return promise.resolve(this.value);
  }

  toString() {
    return `Validation.Success(${this.value})`;
  }
}

module.exports = Validation;
</code></pre>
        </article>
    </section>






        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Jun 02 2016 13:54:13 GMT-0500 (CDT)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/jaguar.js"></script>
</body>
</html>
